function out = PSO(problem, params)
%% Problem Definition
CostFunction = problem.CostFunction;   %Cost function
nVar = length(problem.limits);    % Number of Unknow (Decision) Variables
VarSize = [1 nVar];          %Matrix size of Docision variables

%% Parameters of PSO
MaxIt = params.MaxIt;      %Maximum Number of Iterations;
nPop = params.nPop;        %Swarm Size
w = params.w;            %Inercia Coefficient;
wdamp = params.wdamp;     %Damping Ratio of Inertia Coefficient 
c1 = params.c1;           %Personal Acceleration Coefficient;
c2 = params.c2;           %Social Accelleration Coefficient
ShowInfo = params.ShowIterInfo ; %Flag for parameter info showing
limits = params.limits;

%% Initialization

% The particle Template
empty_particle.Position = [];
empty_particle.Velocity = [];
empty_particle.Cost = [];
empty_particle.Best.Position = [];
empty_particle.Best.Cost = [];

%Create Population Array
particle = repmat(empty_particle,nPop,1);

%Initialize Global Best
GlobalBest.Cost = inf;

referencia_interna = ~isfield(params, 'referencia');
if referencia_interna 
    params.referencia(1:params.n) = 35;
end

fh = figure;
an = animatedline('Marker', 'o');
xlim([0 MaxIt]);
ButtonH = uicontrol('Style', 'ToggleButton', 'String', 'Stop', 'Value', 0);
set(ButtonH,'string','stop','enable','on', 'BackgroundColor','green');
hold on
if params.plotar
    figure;
end
%Initialization of population
for i=1:nPop
    drawnow;
    if get(ButtonH, 'Value') == 1
        keyboard;
    end   
    %Generation Random Solutions
    particle(i).Position = [];
    for j = 1:length(limits)
        particle(i).Position(j) = unifrnd(limits(j).min, limits(j).max);
    end
    
    %Initialize velocity:
    particle(i).Velocity = zeros(VarSize);
    
    %Evaluation
    particle(i).Cost = CostFunction(particle(i).Position);
    hold on
    
    %Update the Personal Best
    particle(i).Best.Position = particle(i).Position;
    particle(i).Best.Cost = particle(i).Cost; 
    if particle(i).Best.Cost < GlobalBest.Cost
        GlobalBest = particle(i).Best;
    end
end

if  ShowInfo
    disp(['Iteration  ', num2str(0) ,'  Best Cost = ',num2str(GlobalBest.Cost)])
    fc = gcf;
    figure(fh);
    addpoints(an, 0, GlobalBest.Cost);
    drawnow;
    figure(fc);
end

BestCosts = zeros(MaxIt,1);

%% Main Loop of PSO
for it=1:MaxIt
    if params.plotar
        figure;
    end  
    if referencia_interna
        if it<=MaxIt/5
            params.referencia(1:params.n) = 20;
        elseif it>MaxIt/5 && it<=2*MaxIt/5
            params.referencia(1:params.n) = 30;
        elseif it>2*MaxIt/5 && it<=3*MaxIt/5
            params.referencia(1:params.n) = 50;
        elseif it>3*MaxIt/5 && it<=4*MaxIt/5
            params.referencia(1:params.n) = 20;
        else
            params.referencia(1:params.n) = 35;
        end
        CostFunction = @(particula) objfunc(script_planta(particula, params), 'ISE');
    end
    
    for i=1:nPop
        drawnow;
        if get(ButtonH, 'Value') == 1
            keyboard;
        end
        %Update velocity
        particle(i).Velocity = w*particle(i).Velocity ...
         + c1*rand(VarSize).*(particle(i).Best.Position - particle(i).Position)...
         + c2*rand(VarSize).*(GlobalBest.Position - particle(i).Position);
        
        %Update position then apply Upper and Lower Bound Limits
        for ii = 1:size(problem.limits,2)
                particle(i).Velocity(ii) = max(particle(i).Velocity(ii), limits(ii).minVelocity);
                particle(i).Velocity(ii) = min(particle(i).Velocity(ii), limits(ii).maxVelocity);
                particle(i).Position(ii) = particle(i).Position(ii) + particle(i).Velocity(ii);
                particle(i).Position(ii) = max(particle(i).Position(ii), limits(ii).min);
                particle(i).Position(ii) = min(particle(i).Position(ii), limits(ii).max);
        end
        
        %Evaluation        
        particle(i).Cost = CostFunction(particle(i).Position);
        if particle(i).Cost < particle(i).Best.Cost
            particle(i).Best.Position = particle(i).Position;
            particle(i).Best.Cost = particle(i).Cost;
            %Update the global best
            if particle(i).Best.Cost < GlobalBest.Cost
                GlobalBest = particle(i).Best;
            end
        end
    end
    
    %Store the best cost Value
    BestCosts(it) = GlobalBest.Cost;
    
    %DIsplay Iteration Information
    if  ShowInfo
        disp(['Iteration  ', num2str(it) ,'  Best Cost = ',num2str(BestCosts(it))])
        fc = gcf;
        figure(fh);
        addpoints(an, it, GlobalBest.Cost);
        drawnow;
        figure(fc);
    end
  
    %Damping Inertia coeficient
    w = w*wdamp;
      
end
    out.BestSol = GlobalBest;
    out.BestCost = BestCosts;
    out.pop = particle;
end